---
layout:     post
title:      å›¾åƒå¤„ç†-ç¬”è®°
subtitle:   Lab-color-spaceã€JPEGå’Œzigzag
date:       2020-04-26
author:     LT
header-img: 
catalog: true
tags:
    - è®¡ç®—æœºè§†è§‰
    - å®è·µç¯‡
    - python
---

### Labé¢œè‰²ç©ºé—´
1. å‘½å
    - Labè‰²å½©ç©ºé—´åœ¨1931å¹´å›½é™…ç…§æ˜å§”å‘˜ä¼šï¼ˆCIEï¼‰åˆ¶å®šçš„é¢œè‰²åº¦é‡å›½é™…æ ‡å‡†çš„åŸºç¡€ä¸Šå»ºç«‹èµ·æ¥çš„ã€‚
    - 1976å¹´ï¼Œç»ä¿®æ”¹åè¢«æ­£å¼å‘½åä¸ºCIELabã€‚
    - æ³¨æ„ï¼Œè¿˜æœ‰ä¸€ä¸ªé¢œè‰²æ¨¡å‹å«åšHunter1948 L,a,bï¼Œæ˜¯ç”±HunterLabå…¬å¸åˆ¶ä½œçš„ã€‚è™½ç„¶å’ŒCIEçš„Labæ¨¡å‹æœ‰äº›å…³è”ï¼Œä½†å®ç°ä¸ä¸€æ ·ã€‚
    - ä¸€èˆ¬æƒ…å†µè¯´Labé¢œè‰²æ¨¡å‹ï¼Œéƒ½æ˜¯æŒ‡CIE-Labæ¨¡å‹ã€‚
2. å–å€¼èŒƒå›´
    - Labé¢œè‰²ç©ºé—´ä¸­çš„Låˆ†é‡ç”¨äºè¡¨ç¤ºåƒç´ çš„äº®åº¦ï¼Œå–å€¼èŒƒå›´æ˜¯[0,100],è¡¨ç¤ºä»çº¯é»‘åˆ°çº¯ç™½ï¼›
    - aè¡¨ç¤ºä»çº¢è‰²åˆ°ç»¿è‰²çš„èŒƒå›´ï¼Œå–å€¼èŒƒå›´æ˜¯[127,-128]ï¼›
    - bè¡¨ç¤ºä»é»„è‰²åˆ°è“è‰²çš„èŒƒå›´ï¼Œå–å€¼èŒƒå›´æ˜¯[127,-128]ã€‚
3. æ•æ„Ÿåº¦
    - äººçœ¼å¯¹äºäº®åº¦Læ•æ„Ÿï¼Œå¯¹äºè‰²åº¦abä¸æ•æ„Ÿã€‚

### JPEGç¼–ç ä¸Zig-Zagæ‰«æ
1. åŠ¨æœºï¼šç”±äºäººçœ¼å¯¹ä½é¢‘æ•æ„Ÿï¼Œé«˜é¢‘ä¸æ•æ„Ÿï¼Œæ‰€ä»¥JPEGå‹ç¼©ï¼Œå°±æ˜¯é€‚å½“ä»¥æŸå¤±é«˜é¢‘åˆ†é‡ä¸ºä»£ä»·ï¼Œä»è€Œå‡å°å›¾åƒå¤§å°ã€‚
2. è¿™é‡Œï¼Œé¢‘åŸŸåˆ†é‡é‡‡å–çš„æ˜¯DCTå˜æ¢ã€‚è§„å¾‹å¦‚ä¸‹ã€‚
    - åœ¨DCTä¹‹å‰ï¼Œå…ˆåˆ†å—ï¼Œä¸€èˆ¬æ˜¯8*8çš„ã€‚
    - å¯¹äºä¸€å¹…å›¾åƒDCTç³»æ•°ï¼Œä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ï¼Œç»å¯¹å€¼ç”±`å¤§ğŸ‘‰å°`ï¼Œ`ä½é¢‘ğŸ‘‰é«˜é¢‘`ã€‚
3. ä¸¤ç±»JPEGç¼–ç ä¿¡æ¯ï¼šDCï¼ˆç›´æµç³»æ•°ï¼‰ã€AC(äº¤æµç³»æ•°)
    - DCï¼ˆç›´æµç³»æ•°ï¼‰:æ¯ä¸ª8*8å­å—ä¸­çš„[0,0]å…ƒç´ ï¼Œä»£è¡¨å­å—çš„å¹³å‡å€¼ã€‚JPEGä¸­å¯¹F[0,0]å•ç‹¬ç¼–ç ï¼Œç”±äºä¸¤ä¸ªç›¸é‚»çš„8Ã—8å­å—çš„DCç³»æ•°ç›¸å·®å¾ˆå°ï¼Œé‡‡ç”¨å·®åˆ†ç¼–ç DPCMï¼Œå¯ä»¥æé«˜å‹ç¼©æ¯”ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹ç›¸é‚»çš„å­å—DCç³»æ•°çš„å·®å€¼è¿›è¡Œç¼–ç ã€‚
    - AC(äº¤æµç³»æ•°)ï¼š8Ã—8å—çš„å…¶å®ƒ63ä¸ªç³»æ•°ã€‚ä¸ºäº†ä¿è¯**ä½é¢‘åˆ†é‡å…ˆå‡ºç°ï¼Œé«˜é¢‘åˆ†é‡åå‡ºç°**ï¼Œ63ä¸ªå…ƒç´ é‡‡ç”¨äº†Zig-Zagæ‰«æï¼Œå¹¶é‡‡ç”¨æ¸¸ç¨‹ç¼–ç ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚![Z](https://img-1300025586.cos.ap-shanghai.myqcloud.com/zigzag.png)

### ä»£ç ç¤ºä¾‹:Zig-Zag
1. ä¸¤ä¸ªå‡½æ•°
    ```
    def zigzag(dct_coef, one_dim_dct, action):
        n = dct_coef.shape[0]
        k = 0

        for i in range(1,n+1):
            for j in range(1,i+1):
                if i % 2 == 0:
                    if action=='init':
                        one_dim_dct[k] = dct_coef[j -1][i+1-j -1]
                    if action=='modify':
                        dct_coef[j -1][i+1-j -1] = one_dim_dct[k]
                else:
                    if action=='init':
                        one_dim_dct[k] = dct_coef[i+1-j -1][j -1]
                    if action=='modify':
                        dct_coef[i+1-j -1][j -1] = one_dim_dct[k]
                k = k + 1

        for i in range(1, n):
            for j in range(1, n - i+1):
                if i % 2 == 0:
                    if action=='init':
                        one_dim_dct[k] = dct_coef[n-j+1 -1][i + j -1]
                    if action=='modify':
                        dct_coef[n-j+1 -1][i + j -1] = one_dim_dct[k]
                else:
                    if action=='init':
                        one_dim_dct[k] = dct_coef[i + j -1][n-j+1 -1]
                    if action=='modify':
                        dct_coef[i + j -1][n-j+1 -1] = one_dim_dct[k]
                k = k + 1
        return dct_coef, one_dim_dct
    def blk_triangle_replace_HighDCT(gray_img, x_64_8_sample):
        height, width, size_y,  size_x, channels = 8,8, 8,8,1
        recon_img_complete = np.zeros((height * size_y, width * size_x))
        for i in range(gray_img.shape[0]//8):
            for j in range(gray_img.shape[0] // 8):
                blk_img = gray_img[i*8: (i+1)*8, j*8: (j+1)*8]
                blk_dct = cv2.dct(blk_img)
                init_one_dim_dct = np.random.randint(0, 1, size=(8*8)).astype(np.float32)
                _, one_dim_dct = zigzag(blk_dct, init_one_dim_dct, 'init')
                # ä¿®æ”¹äº†å³ä¸‹è§’ï¼ˆä¸‰è§’å½¢,é¢ç§¯å 1/8ï¼‰ä¹‹åçš„DCTçŸ©é˜µ
                one_dim_dct[np.prod(blk_dct.shape) // 8 * 7:] = x_64_8_sample[8*i+j]
                blk_dct, _ = zigzag(blk_dct, one_dim_dct, 'modify')

                recon_img = cv2.idct(blk_dct)
                recon_img_complete[i * height:(i + 1) * height, j*height:(j + 1) * height] = recon_img

        return recon_img_complete.astype(np.uint8)
    ```
2. ä½¿ç”¨
    ```
    def plot_images(args, x_sample, dir, file_name, size_x=10, size_y=10):
        folder = '../{}/train_64x64/images0/'.format(args.img_folder)
        val_namelist = os.listdir(folder)
        val_namelist = val_namelist[len(val_namelist) //5*4: ]
        random.shuffle(val_namelist)

        print(x_sample.shape)
        batch, channels, height, width = x_sample.shape[0], x_sample.shape[1], x_sample.shape[2], 8*x_sample.shape[3]
        mosaic = np.zeros((height * size_y, width * size_x, channels))
        # ç”¨ç”Ÿæˆçš„é«˜é¢‘DCT(ä¸‹ä¸‰è§’)æ›¿æ¢åŸå›¾ï¼ˆä»valä¸­éšæœºé€‰æ‹©ï¼‰çš„DCTï¼Œå†iDCT
        for j in range(size_y):
            for i in range(size_x):
                idx = j * size_x + i
                gray_img = cv2.imread(folder+val_namelist[idx]).transpose(2, 0, 1).astype(np.float32)[0]

                image = blk_triangle_replace_HighDCT(gray_img, x_sample[idx].squeeze())
                mosaic[j*height:(j+1)*height, i*height:(i+1)*height] = torch.tensor(image).unsqueeze(dim=2).numpy()

        # Remove channel for BW images
        mosaic = mosaic.squeeze()
        cv2.imwrite(dir + file_name + '.png', mosaic)
    ```



